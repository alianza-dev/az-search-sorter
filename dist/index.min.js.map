{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///dist/index.min.js","webpack:///webpack/bootstrap 457ce7f069c584dfdfdc","webpack:///./index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","azSearchSorter","givenString","arguments","length","undefined","thingsToSearch","options","toLowerCase","map","obj","stringToMatch","propToMatch","score","_stringsMatch","filter","item","keepNonMatching","sort","itemA","itemB","_matchRankMap","noMatch","equals","indexOf","startsWith","wordStartsWith","contains","_isAcronym","acronym","_stringsByCharOrder","getAcronymIndexes","matchingIndexes","charNumber","split","forEach","matchChar","index","isFirst","findIndex","push","_getAcronym","string","wordsInString","wordInString","splitByHyphenWords","splitByHyphenWord","substr","getMatchingStringIndexes","matches","every","Object","defineProperty","value"],"mappings":"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","file":"dist/index.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"azSearchSorter\"] = factory();\n\telse\n\t\troot[\"azSearchSorter\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","//! az-search-sorter version 1.0.1 built with ♥ by Kent C. Dodds <kent@doddsfamily.us> (http://kentcdodds.com) (ó ì_í)=óò=(ì_í ò)\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"azSearchSorter\"] = factory();\n\telse\n\t\troot[\"azSearchSorter\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\t// The bulk for this file was taken from genie.js\n\t/* eslint no-underscore-dangle:0 */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\tvar _matchRankMap = {\n\t  equals: 5,\n\t  startsWith: 4,\n\t  wordStartsWith: 3,\n\t  contains: 2,\n\t  acronym: 1,\n\t  matches: 0,\n\t  noMatch: -1\n\t};\n\t\n\tazSearchSorter.getMatchingStringIndexes = getMatchingStringIndexes;\n\tazSearchSorter.getAcronymIndexes = getAcronymIndexes;\n\t\n\texports['default'] = azSearchSorter;\n\t\n\tfunction azSearchSorter() {\n\t  var givenString = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n\t  var thingsToSearch = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\t  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\t\n\t  givenString = givenString.toLowerCase();\n\t  return thingsToSearch.map(function (obj) {\n\t    // score items\n\t    var stringToMatch = options.propToMatch ? obj[options.propToMatch] : obj;\n\t    var score = _stringsMatch(stringToMatch, givenString);\n\t    return { obj: obj, score: score };\n\t  }).filter(function (item) {\n\t    return options.keepNonMatching || item.score > -1;\n\t  }).sort(function (itemA, itemB) {\n\t    if (itemA.score < itemB.score) {\n\t      return 1;\n\t    } else if (itemA.score > itemB.score) {\n\t      return -1;\n\t    } else {\n\t      return 0;\n\t    }\n\t  }).map(function (item) {\n\t    return item.obj;\n\t  }); // get the value and reverse it (best match first)\n\t}\n\t\n\t/**\n\t * Gives a _matchRankMap score based on\n\t * how well the two strings match.\n\t * @param {string} stringToMatch - the string to rank against\n\t * @param {string} givenString - the given string to rank\n\t * @returns {number} - the rank\n\t * @private\n\t */\n\tfunction _stringsMatch(stringToMatch, givenString) {\n\t  /* eslint complexity:[2, 8] */\n\t  stringToMatch = ('' + stringToMatch).toLowerCase();\n\t\n\t  // too long\n\t  if (givenString.length > stringToMatch.length) {\n\t    return _matchRankMap.noMatch;\n\t  }\n\t\n\t  // equals\n\t  if (stringToMatch === givenString) {\n\t    return _matchRankMap.equals;\n\t  }\n\t\n\t  // starts with\n\t  if (stringToMatch.indexOf(givenString) === 0) {\n\t    return _matchRankMap.startsWith;\n\t  }\n\t\n\t  // word starts with\n\t  if (stringToMatch.indexOf(' ' + givenString) !== -1) {\n\t    return _matchRankMap.wordStartsWith;\n\t  }\n\t\n\t  // contains\n\t  if (stringToMatch.indexOf(givenString) !== -1) {\n\t    return _matchRankMap.contains;\n\t  } else if (givenString.length === 1) {\n\t    // If the only character in the given magic word\n\t    //   isn't even contained in the magic word, then\n\t    //   it's definitely not a match.\n\t    return _matchRankMap.noMatch;\n\t  }\n\t\n\t  // acronym\n\t  if (_isAcronym(stringToMatch, givenString)) {\n\t    return _matchRankMap.acronym;\n\t  }\n\t\n\t  return _stringsByCharOrder(stringToMatch, givenString);\n\t}\n\t\n\tfunction getAcronymIndexes() {\n\t  var stringToMatch = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n\t  var givenString = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];\n\t\n\t  var matchingIndexes = null;\n\t  stringToMatch = stringToMatch.toLowerCase();\n\t  givenString = givenString.toLowerCase();\n\t  if (_isAcronym(stringToMatch, givenString)) {\n\t    (function () {\n\t      var charNumber = -1;\n\t      matchingIndexes = [];\n\t      givenString.split('').forEach(function (matchChar, index) {\n\t        var isFirst = index === 0;\n\t        var findIndex = isFirst ? matchChar : ' ' + matchChar;\n\t        charNumber = stringToMatch.indexOf(findIndex, charNumber + 1);\n\t        charNumber += isFirst ? 0 : 1;\n\t        matchingIndexes.push(charNumber);\n\t      });\n\t    })();\n\t  }\n\t  return matchingIndexes;\n\t}\n\t\n\tfunction _isAcronym(stringToMatch, givenString) {\n\t  return _getAcronym(stringToMatch).indexOf(givenString) !== -1;\n\t}\n\t\n\t/**\n\t * Generates an acronym for a string.\n\t *\n\t * @param {string} string - the string to generate the acronym for\n\t * @returns {string} - the acronym\n\t * @private\n\t * @examples\n\t * _getAcronym('i love candy') // => 'ilc'\n\t * _getAcronym('water-fall in the spring-time') // => 'wfitst'\n\t */\n\tfunction _getAcronym(string) {\n\t  var acronym = '';\n\t  var wordsInString = string.split(' ');\n\t  wordsInString.forEach(function (wordInString) {\n\t    var splitByHyphenWords = wordInString.split('-');\n\t    splitByHyphenWords.forEach(function (splitByHyphenWord) {\n\t      acronym += splitByHyphenWord.substr(0, 1);\n\t    });\n\t  });\n\t  return acronym;\n\t}\n\t\n\t/**\n\t * Returns a _matchRankMap.matches or noMatch score based on whether\n\t * the characters in the givenString are found in order in the\n\t * stringToMatch\n\t * @param {string} stringToMatch - the string to match\n\t * @param {string} givenString - the string that is given\n\t * @returns {number} - matches rank or noMatch rank\n\t * @private\n\t */\n\tfunction _stringsByCharOrder(stringToMatch, givenString) {\n\t  var matchingIndexes = getMatchingStringIndexes(stringToMatch, givenString);\n\t  if (!matchingIndexes || !matchingIndexes.length) {\n\t    return _matchRankMap.noMatch;\n\t  } else {\n\t    return _matchRankMap.matches;\n\t  }\n\t}\n\t\n\tfunction getMatchingStringIndexes(stringToMatch, givenString) {\n\t  var charNumber = -1;\n\t  var matchingIndexes = [];\n\t  givenString.split('').every(function (matchChar) {\n\t    charNumber = stringToMatch.indexOf(matchChar, charNumber + 1);\n\t    if (charNumber === -1) {\n\t      matchingIndexes = null;\n\t    } else {\n\t      matchingIndexes.push(charNumber);\n\t      return true;\n\t    }\n\t  });\n\t  return matchingIndexes;\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** dist/index.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 457ce7f069c584dfdfdc\n **/","// The bulk for this file was taken from genie.js\n/* eslint no-underscore-dangle:0 */\nconst _matchRankMap = {\n  equals: 5,\n  startsWith: 4,\n  wordStartsWith: 3,\n  contains: 2,\n  acronym: 1,\n  matches: 0,\n  noMatch: -1\n};\n\nazSearchSorter.getMatchingStringIndexes = getMatchingStringIndexes;\nazSearchSorter.getAcronymIndexes = getAcronymIndexes;\n\nexport default azSearchSorter;\n\nfunction azSearchSorter(givenString = '', thingsToSearch = [], options = {}) {\n  givenString = givenString.toLowerCase();\n  return thingsToSearch\n    .map(function(obj) { // score items\n      const stringToMatch = options.propToMatch ? obj[options.propToMatch] : obj;\n      const score = _stringsMatch(stringToMatch, givenString);\n      return {obj, score};\n    })\n    .filter(item => options.keepNonMatching || item.score > -1)\n    .sort((itemA, itemB) => {\n      if (itemA.score < itemB.score) {\n        return 1;\n      } else if (itemA.score > itemB.score) {\n        return -1;\n      } else {\n        return 0;\n      }\n    })\n    .map(item => item.obj); // get the value and reverse it (best match first)\n}\n\n/**\n * Gives a _matchRankMap score based on\n * how well the two strings match.\n * @param {string} stringToMatch - the string to rank against\n * @param {string} givenString - the given string to rank\n * @returns {number} - the rank\n * @private\n */\nfunction _stringsMatch(stringToMatch, givenString) {\n  /* eslint complexity:[2, 8] */\n  stringToMatch = ('' + stringToMatch).toLowerCase();\n\n  // too long\n  if (givenString.length > stringToMatch.length) {\n    return _matchRankMap.noMatch;\n  }\n\n  // equals\n  if (stringToMatch === givenString) {\n    return _matchRankMap.equals;\n  }\n\n  // starts with\n  if (stringToMatch.indexOf(givenString) === 0) {\n    return _matchRankMap.startsWith;\n  }\n\n  // word starts with\n  if (stringToMatch.indexOf(' ' + givenString) !== -1) {\n    return _matchRankMap.wordStartsWith;\n  }\n\n  // contains\n  if (stringToMatch.indexOf(givenString) !== -1) {\n    return _matchRankMap.contains;\n  } else if (givenString.length === 1) {\n    // If the only character in the given magic word\n    //   isn't even contained in the magic word, then\n    //   it's definitely not a match.\n    return _matchRankMap.noMatch;\n  }\n\n  // acronym\n  if (_isAcronym(stringToMatch, givenString)) {\n    return _matchRankMap.acronym;\n  }\n\n  return _stringsByCharOrder(stringToMatch, givenString);\n}\n\nfunction getAcronymIndexes(stringToMatch = '', givenString = '') {\n  let matchingIndexes = null;\n  stringToMatch = stringToMatch.toLowerCase();\n  givenString = givenString.toLowerCase();\n  if (_isAcronym(stringToMatch, givenString)) {\n    let charNumber = -1;\n    matchingIndexes = [];\n    givenString.split('').forEach(function(matchChar, index) {\n      const isFirst = index === 0;\n      const findIndex = isFirst ? matchChar : ' ' + matchChar;\n      charNumber = stringToMatch.indexOf(findIndex, charNumber + 1);\n      charNumber += isFirst ? 0 : 1;\n      matchingIndexes.push(charNumber);\n    });\n  }\n  return matchingIndexes;\n}\n\nfunction _isAcronym(stringToMatch, givenString) {\n  return _getAcronym(stringToMatch).indexOf(givenString) !== -1;\n}\n\n/**\n * Generates an acronym for a string.\n *\n * @param {string} string - the string to generate the acronym for\n * @returns {string} - the acronym\n * @private\n * @examples\n * _getAcronym('i love candy') // => 'ilc'\n * _getAcronym('water-fall in the spring-time') // => 'wfitst'\n */\nfunction _getAcronym(string) {\n  let acronym = '';\n  const wordsInString = string.split(' ');\n  wordsInString.forEach(function(wordInString) {\n    const splitByHyphenWords = wordInString.split('-');\n    splitByHyphenWords.forEach(function(splitByHyphenWord) {\n      acronym += splitByHyphenWord.substr(0, 1);\n    });\n  });\n  return acronym;\n}\n\n/**\n * Returns a _matchRankMap.matches or noMatch score based on whether\n * the characters in the givenString are found in order in the\n * stringToMatch\n * @param {string} stringToMatch - the string to match\n * @param {string} givenString - the string that is given\n * @returns {number} - matches rank or noMatch rank\n * @private\n */\nfunction _stringsByCharOrder(stringToMatch, givenString) {\n  const matchingIndexes = getMatchingStringIndexes(stringToMatch, givenString);\n  if (!matchingIndexes || !matchingIndexes.length) {\n    return _matchRankMap.noMatch;\n  } else {\n    return _matchRankMap.matches;\n  }\n}\n\nfunction getMatchingStringIndexes(stringToMatch, givenString) {\n  let charNumber = -1;\n  let matchingIndexes = [];\n  givenString.split('').every(function(matchChar) {\n    charNumber = stringToMatch.indexOf(matchChar, charNumber + 1);\n    if (charNumber === -1) {\n      matchingIndexes = null;\n    } else {\n      matchingIndexes.push(charNumber);\n      return true;\n    }\n  });\n  return matchingIndexes;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../~/eslint-loader!./index.js\n **/"],"sourceRoot":""}